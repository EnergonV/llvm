// generated by gen.go using 'go generate'; DO NOT EDIT.

// === [ Bitwise binary instructions ] =========================================
//
// References:
//    http://llvm.org/docs/LangRef.html#bitwise-binary-operations

package instruction

import (
	"fmt"

	"github.com/llir/llvm/ir/types"
	"github.com/llir/llvm/ir/value"
	"github.com/mewkiz/pkg/errutil"
)

// --- [ shl ] -----------------------------------------------------------------

// ShL represents a shift left instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#shl-instruction
type ShL struct {
	// Operands.
	x, y value.Value
}

// NewShL returns a new shl instruction based on the given operands.
func NewShL(x, y value.Value) (*ShL, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &ShL{x: x, y: y}, nil
}

// Type returns the type of the value produced by the instruction.
func (inst *ShL) Type() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *ShL) String() string {
	return fmt.Sprintf("shl %v %v, %v", inst.x.Type(), inst.x, inst.y)
}

// --- [ lshr ] ----------------------------------------------------------------

// LShR represents a logical shift right instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#lshr-instruction
type LShR struct {
	// Operands.
	x, y value.Value
}

// NewLShR returns a new lshr instruction based on the given operands.
func NewLShR(x, y value.Value) (*LShR, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &LShR{x: x, y: y}, nil
}

// Type returns the type of the value produced by the instruction.
func (inst *LShR) Type() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *LShR) String() string {
	return fmt.Sprintf("lshr %v %v, %v", inst.x.Type(), inst.x, inst.y)
}

// --- [ ashr ] ----------------------------------------------------------------

// AShR represents an arithmetic shift right instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#ashr-instruction
type AShR struct {
	// Operands.
	x, y value.Value
}

// NewAShR returns a new ashr instruction based on the given operands.
func NewAShR(x, y value.Value) (*AShR, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &AShR{x: x, y: y}, nil
}

// Type returns the type of the value produced by the instruction.
func (inst *AShR) Type() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *AShR) String() string {
	return fmt.Sprintf("ashr %v %v, %v", inst.x.Type(), inst.x, inst.y)
}

// --- [ and ] -----------------------------------------------------------------

// And represents an AND instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#and-instruction
type And struct {
	// Operands.
	x, y value.Value
}

// NewAnd returns a new and instruction based on the given operands.
func NewAnd(x, y value.Value) (*And, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &And{x: x, y: y}, nil
}

// Type returns the type of the value produced by the instruction.
func (inst *And) Type() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *And) String() string {
	return fmt.Sprintf("and %v %v, %v", inst.x.Type(), inst.x, inst.y)
}

// --- [ or ] ------------------------------------------------------------------

// Or represents an OR instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#or-instruction
type Or struct {
	// Operands.
	x, y value.Value
}

// NewOr returns a new or instruction based on the given operands.
func NewOr(x, y value.Value) (*Or, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &Or{x: x, y: y}, nil
}

// Type returns the type of the value produced by the instruction.
func (inst *Or) Type() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *Or) String() string {
	return fmt.Sprintf("or %v %v, %v", inst.x.Type(), inst.x, inst.y)
}

// --- [ xor ] -----------------------------------------------------------------

// Xor represents an exclusive-OR instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#xor-instruction
type Xor struct {
	// Operands.
	x, y value.Value
}

// NewXor returns a new xor instruction based on the given operands.
func NewXor(x, y value.Value) (*Xor, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &Xor{x: x, y: y}, nil
}

// Type returns the type of the value produced by the instruction.
func (inst *Xor) Type() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *Xor) String() string {
	return fmt.Sprintf("xor %v %v, %v", inst.x.Type(), inst.x, inst.y)
}

// isValueInst ensures that only instructions which return values can be
// assigned to the Value interface.
func (*ShL) isValueInst()  {}
func (*LShR) isValueInst() {}
func (*AShR) isValueInst() {}
func (*And) isValueInst()  {}
func (*Or) isValueInst()   {}
func (*Xor) isValueInst()  {}
