// generated by gen.go using 'go generate'; DO NOT EDIT.

// {{ h1 .Desc }}
//
// References:
//    {{ .URL }}

package instruction

import (
	"fmt"

	"github.com/llir/llvm/ir/types"
	"github.com/llir/llvm/ir/value"
	"github.com/mewkiz/pkg/errutil"
)

{{- range .Insts }}
// {{ lower .Name | h2 }}

// {{ .Name }} represents {{ .Desc }} instruction.
//
// References:
//    http://llvm.org/docs/LangRef.html#{{ lower .Name }}-instruction
type {{ .Name }} struct {
	// Operands.
	x, y value.Value
}

// New{{ .Name }} returns a new {{ lower .Name }} instruction based on the given operands.
func New{{ .Name }}(x, y value.Value) (*{{ .Name }}, error) {
	if !types.Equal(x.Type(), y.Type()) {
		return nil, errutil.Newf("type mismatch between x (%v) and y (%v)", x.Type(), y.Type())
	}
	return &{{ .Name }}{x: x, y: y}, nil
}

// X returns the x operand of the {{ lower .Name }} instruction.
func (inst *{{ .Name }}) X() value.Value {
	return inst.x
}

// Y returns the y operand of the {{ lower .Name }} instruction.
func (inst *{{ .Name }}) Y() value.Value {
	return inst.y
}

// RetType returns the type of the value produced by the instruction.
func (inst *{{ .Name }}) RetType() types.Type {
	return inst.x.Type()
}

// String returns the string representation of the instruction.
func (inst *{{ .Name }}) String() string {
	x, y := inst.X(), inst.Y()
	return fmt.Sprintf("{{ lower .Name }} %v %v, %v", x.Type(), x.ValueString(), y.ValueString())
}
{{- end }}
