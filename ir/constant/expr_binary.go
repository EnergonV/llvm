// generated by gen.go using 'go generate'; DO NOT EDIT.

// === [ Binary expressions ] ==================================================
//
// References:
//    http://llvm.org/docs/LangRef.html#binary-operations

package constant

import (
	"fmt"

	"github.com/llir/llvm/ir/types"
)

// --- [ add ] -----------------------------------------------------------------

// ExprAdd represents an addition expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#add-instruction
type ExprAdd struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewAdd returns a new add expression based on the given operands.
func NewAdd(x, y Constant) *ExprAdd {
	expr := &ExprAdd{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprAdd) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprAdd) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("add (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprAdd) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprAdd) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the add expression.
func (expr *ExprAdd) X() Constant {
	return expr.x
}

// Y returns the y operand of the add expression.
func (expr *ExprAdd) Y() Constant {
	return expr.y
}

// --- [ fadd ] ----------------------------------------------------------------

// ExprFAdd represents a floating-point addition expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fadd-instruction
type ExprFAdd struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewFAdd returns a new fadd expression based on the given operands.
func NewFAdd(x, y Constant) *ExprFAdd {
	expr := &ExprFAdd{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprFAdd) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFAdd) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("fadd (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFAdd) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFAdd) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the fadd expression.
func (expr *ExprFAdd) X() Constant {
	return expr.x
}

// Y returns the y operand of the fadd expression.
func (expr *ExprFAdd) Y() Constant {
	return expr.y
}

// --- [ sub ] -----------------------------------------------------------------

// ExprSub represents a subtraction expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#sub-instruction
type ExprSub struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewSub returns a new sub expression based on the given operands.
func NewSub(x, y Constant) *ExprSub {
	expr := &ExprSub{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprSub) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprSub) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("sub (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprSub) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprSub) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the sub expression.
func (expr *ExprSub) X() Constant {
	return expr.x
}

// Y returns the y operand of the sub expression.
func (expr *ExprSub) Y() Constant {
	return expr.y
}

// --- [ fsub ] ----------------------------------------------------------------

// ExprFSub represents a floating-point subtraction expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fsub-instruction
type ExprFSub struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewFSub returns a new fsub expression based on the given operands.
func NewFSub(x, y Constant) *ExprFSub {
	expr := &ExprFSub{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprFSub) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFSub) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("fsub (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFSub) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFSub) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the fsub expression.
func (expr *ExprFSub) X() Constant {
	return expr.x
}

// Y returns the y operand of the fsub expression.
func (expr *ExprFSub) Y() Constant {
	return expr.y
}

// --- [ mul ] -----------------------------------------------------------------

// ExprMul represents a multiplication expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#mul-instruction
type ExprMul struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewMul returns a new mul expression based on the given operands.
func NewMul(x, y Constant) *ExprMul {
	expr := &ExprMul{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprMul) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprMul) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("mul (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprMul) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprMul) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the mul expression.
func (expr *ExprMul) X() Constant {
	return expr.x
}

// Y returns the y operand of the mul expression.
func (expr *ExprMul) Y() Constant {
	return expr.y
}

// --- [ fmul ] ----------------------------------------------------------------

// ExprFMul represents a floating-point multiplication expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fmul-instruction
type ExprFMul struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewFMul returns a new fmul expression based on the given operands.
func NewFMul(x, y Constant) *ExprFMul {
	expr := &ExprFMul{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprFMul) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFMul) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("fmul (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFMul) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFMul) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the fmul expression.
func (expr *ExprFMul) X() Constant {
	return expr.x
}

// Y returns the y operand of the fmul expression.
func (expr *ExprFMul) Y() Constant {
	return expr.y
}

// --- [ udiv ] ----------------------------------------------------------------

// ExprUDiv represents an unsigned division expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#udiv-instruction
type ExprUDiv struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewUDiv returns a new udiv expression based on the given operands.
func NewUDiv(x, y Constant) *ExprUDiv {
	expr := &ExprUDiv{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprUDiv) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprUDiv) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("udiv (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprUDiv) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprUDiv) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the udiv expression.
func (expr *ExprUDiv) X() Constant {
	return expr.x
}

// Y returns the y operand of the udiv expression.
func (expr *ExprUDiv) Y() Constant {
	return expr.y
}

// --- [ sdiv ] ----------------------------------------------------------------

// ExprSDiv represents a signed division expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#sdiv-instruction
type ExprSDiv struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewSDiv returns a new sdiv expression based on the given operands.
func NewSDiv(x, y Constant) *ExprSDiv {
	expr := &ExprSDiv{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprSDiv) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprSDiv) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("sdiv (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprSDiv) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprSDiv) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the sdiv expression.
func (expr *ExprSDiv) X() Constant {
	return expr.x
}

// Y returns the y operand of the sdiv expression.
func (expr *ExprSDiv) Y() Constant {
	return expr.y
}

// --- [ fdiv ] ----------------------------------------------------------------

// ExprFDiv represents a floating-point division expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#fdiv-instruction
type ExprFDiv struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewFDiv returns a new fdiv expression based on the given operands.
func NewFDiv(x, y Constant) *ExprFDiv {
	expr := &ExprFDiv{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprFDiv) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFDiv) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("fdiv (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFDiv) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFDiv) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the fdiv expression.
func (expr *ExprFDiv) X() Constant {
	return expr.x
}

// Y returns the y operand of the fdiv expression.
func (expr *ExprFDiv) Y() Constant {
	return expr.y
}

// --- [ urem ] ----------------------------------------------------------------

// ExprURem represents an unsigned remainder expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#urem-instruction
type ExprURem struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewURem returns a new urem expression based on the given operands.
func NewURem(x, y Constant) *ExprURem {
	expr := &ExprURem{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprURem) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprURem) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("urem (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprURem) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprURem) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the urem expression.
func (expr *ExprURem) X() Constant {
	return expr.x
}

// Y returns the y operand of the urem expression.
func (expr *ExprURem) Y() Constant {
	return expr.y
}

// --- [ srem ] ----------------------------------------------------------------

// ExprSRem represents a signed remainder expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#srem-instruction
type ExprSRem struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewSRem returns a new srem expression based on the given operands.
func NewSRem(x, y Constant) *ExprSRem {
	expr := &ExprSRem{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprSRem) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprSRem) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("srem (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprSRem) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprSRem) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the srem expression.
func (expr *ExprSRem) X() Constant {
	return expr.x
}

// Y returns the y operand of the srem expression.
func (expr *ExprSRem) Y() Constant {
	return expr.y
}

// --- [ frem ] ----------------------------------------------------------------

// ExprFRem represents a floating-point remainder expression.
//
// References:
//    http://llvm.org/docs/LangRef.html#frem-instruction
type ExprFRem struct {
	// Operands.
	x, y Constant
	// Track uses of the value.
	used
}

// NewFRem returns a new frem expression based on the given operands.
func NewFRem(x, y Constant) *ExprFRem {
	expr := &ExprFRem{x: x, y: y}
	trackConstant(&expr.x, expr)
	trackConstant(&expr.y, expr)
	return expr
}

// Type returns the type of the constant expression.
func (expr *ExprFRem) Type() types.Type {
	return expr.x.Type()
}

// Ident returns the string representation of the constant expression.
func (expr *ExprFRem) Ident() string {
	x, y := expr.X(), expr.Y()
	return fmt.Sprintf("frem (%s %s, %s %s)",
		x.Type(),
		x.Ident(),
		y.Type(),
		y.Ident())
}

// Immutable ensures that only constants can be assigned to the
// constant.Constant interface.
func (*ExprFRem) Immutable() {}

// Simplify returns a simplified version of the constant expression.
func (expr *ExprFRem) Simplify() Constant {
	panic("not yet implemented")
}

// X returns the x operand of the frem expression.
func (expr *ExprFRem) X() Constant {
	return expr.x
}

// Y returns the y operand of the frem expression.
func (expr *ExprFRem) Y() Constant {
	return expr.y
}
